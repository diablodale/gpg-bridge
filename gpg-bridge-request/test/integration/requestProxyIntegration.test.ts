/**
 * Phase 2 Integration Tests: request-proxy → agent-proxy → Real gpg-agent
 *
 * Exercises the full proxy chain:
 *   AssuanSocketClient → Unix socket (Linux) → request-proxy
 *   → VS Code command routing → agent-proxy (Windows) → gpg-agent (Windows)
 *
 * No gpg binary is needed on the Linux side; tests speak the Assuan protocol
 * directly using AssuanSocketClient. The Unix socket is created by request-proxy
 * during activate() (VSCODE_INTEGRATION_TEST=1 causes full initialization).
 *
 * Prerequisites (all managed by runTest.ts BEFORE the extension hosts launch):
 *   - GNUPGHOME is a fresh temp directory (Windows side) passed via extensionTestsEnv
 *   - gpg-agent is running in GNUPGHOME (Windows); agent-proxy is connected to it
 *   - VSCODE_INTEGRATION_TEST=1 causes both extensions to run full initialization
 *   - request-proxy is started and listening on a Unix socket
 *   - TEST_KEY_FINGERPRINT and TEST_KEY_KEYGRIP in process.env, sourced from devcontainer.json
 *     remoteEnv ${localEnv:...} substitution (injected from extensionTestsEnv via VS Code process
 *     env); required by test 5 — PKSIGN sign flow; missing value fails the before() hook
 *
 * Socket path discovery: the '_gpg-bridge-request.test.getSocketPath' VS Code command
 * returns the active socket path. It is only registered when VSCODE_INTEGRATION_TEST=1.
 */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import { spawnSync } from 'child_process';
import { expect } from 'chai';
import { AssuanSocketClient } from '@gpg-bridge/shared/test/integration';

// ---------------------------------------------------------------------------
// Suite
// ---------------------------------------------------------------------------

describe('Phase 2 — request-proxy → agent-proxy → Real gpg-agent', function () {
    // Full proxy chain involves real socket I/O + VS Code command round-trips; be generous.
    this.timeout(60000);

    let socketPath: string;
    let keygrip: string;

    before(async function () {
        // request-proxy uses onStartupFinished activation, which fires AFTER the test
        // runner (* activation). Poll until the command is registered (up to 30 s).
        let path: string | null | undefined = undefined;
        const deadline = Date.now() + 30000;
        while (Date.now() < deadline) {
            try {
                path = await vscode.commands.executeCommand<string | null>(
                    '_gpg-bridge-request.test.getSocketPath'
                );
                break; // command found — proxy may have returned null if it failed to start
            } catch {
                // Command not yet registered — extension hasn't activated yet; keep waiting.
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }
        if (path === undefined) {
            throw new Error(
                '_gpg-bridge-request.test.getSocketPath not registered after 30 s. ' +
                'Verify VSCODE_INTEGRATION_TEST=1 in the container env and that ' +
                'request-proxy extension is loading in the remote extension host.'
            );
        }
        if (!path) {
            throw new Error(
                '_gpg-bridge-request.test.getSocketPath returned null. ' +
                'Check that request-proxy started without errors (VSCODE_INTEGRATION_TEST must be 1).'
            );
        }
        socketPath = path;

        // PKSIGN test (test 5) needs the keygrip generated by runTest.ts.
        // Flows here via: extensionTestsEnv → VS Code process env → devcontainer.json
        // remoteEnv ${localEnv:TEST_KEY_KEYGRIP} → container remote extension host process.env.
        keygrip = process.env.TEST_KEY_KEYGRIP ?? '';
        if (!keygrip) {
            throw new Error('TEST_KEY_KEYGRIP is not set. Check runTest.ts extensionTestsEnv and devcontainer.json remoteEnv.');
        }
    });

    after(async function () {
        // Reset extension state so subsequent test runs start clean.
        // No-op if test 8 already stopped the proxy.
        try {
            await vscode.commands.executeCommand('gpg-bridge-request.stop');
        } catch { /* ignore */ }
    });

    // -----------------------------------------------------------------------
    // 1. Server starts and socket created
    // -----------------------------------------------------------------------
    it('1. request-proxy started and socket file exists at expected path', async function () {
        expect(socketPath).to.be.a('string').and.have.length.greaterThan(0);
        expect(fs.existsSync(socketPath), `socket file should exist at ${socketPath}`).to.be.true;

        // Check permissions: all users must be able to read/write (0o666).
        const stat = fs.statSync(socketPath);
        const mode = stat.mode & 0o777;
        expect(mode, `socket permissions should be 0o666, got 0o${mode.toString(8)}`).to.equal(0o666);
    });

    // -----------------------------------------------------------------------
    // 2. Full GETINFO round-trip via socket client
    // -----------------------------------------------------------------------
    it('2. GETINFO version round-trip returns version data ending with OK', async function () {
        const client = new AssuanSocketClient();
        try {
            const greeting = await client.connect(socketPath);
            expect(greeting).to.match(/^OK/, `greeting should start with OK, got: ${greeting.trim()}`);

            const response = await client.sendCommand('GETINFO version');
            // Extra socket returns version as a D (data) record: 'D 2.4.8\nOK\n'
            expect(response).to.match(/^D \d+\.\d+/m, 'response should contain D <version>');
            expect(response).to.match(/OK\s*$/m, 'response should end with OK');
        } finally {
            client.close();
        }
    });

    // -----------------------------------------------------------------------
    // 3. ERR response forwarded intact
    // -----------------------------------------------------------------------
    it('3. unknown command returns ERR forwarded from agent', async function () {
        const client = new AssuanSocketClient();
        try {
            await client.connect(socketPath);
            const response = await client.sendCommand('NOTACOMMAND');
            expect(response).to.match(/^ERR/m, 'ERR response should be forwarded from agent');
        } finally {
            client.close();
        }
    });

    // -----------------------------------------------------------------------
    // 4. Multiple sequential commands in one session
    // -----------------------------------------------------------------------
    it('4. multiple sequential commands in one session all succeed', async function () {
        const client = new AssuanSocketClient();
        try {
            await client.connect(socketPath);

            // GETINFO version — always valid on the extra socket
            const r1 = await client.sendCommand('GETINFO version');
            expect(r1).to.match(/^D \d+/m, 'GETINFO version should return D <version>');
            expect(r1).to.match(/OK\s*$/m);

            // RESET — idempotent state reset
            const r2 = await client.sendCommand('RESET');
            expect(r2).to.match(/OK\s*$/m, 'RESET should return OK');

            // GETINFO version again — session is still live
            const r3 = await client.sendCommand('GETINFO version');
            expect(r3).to.match(/^D \d+/m);
            expect(r3).to.match(/OK\s*$/m);
        } finally {
            client.close();
        }
    });

    // -----------------------------------------------------------------------
    // 5. PKSIGN flow through proxy (full sign sequence)
    //
    // Real-world sequence for extra socket, Ed25519 key, no passphrase:
    //   OPTION agent-awareness=2.1.0  → OK
    //   RESET                         → OK
    //   SIGKEY <keygrip>              → OK   (keygrip, not fingerprint)
    //   SETKEYDESC <url-encoded desc> → OK
    //   SETHASH 10 <sha512-hex>       → OK   (algo 10 = GCRY_MD_SHA512)
    //   PKSIGN                        → D <binary-sig> + OK
    //
    // Notes:
    // - OPTION allow-pinentry-notify is FORBIDDEN on the extra socket (returns ERR Forbidden).
    //   Do not send it — agent-proxy always uses the extra socket.
    // - SIGKEY takes a keygrip (40-char hex from 'grp:' field), not a fingerprint.
    // - With a no-passphrase key PKSIGN returns D <sig> + OK directly (no INQUIRE).
    //   INQUIRE PINENTRY_LAUNCHED only appears with passphrase-protected keys.
    // -----------------------------------------------------------------------
    it('5. PKSIGN sign flow returns D <signature> + OK through the proxy chain', async function () {
        const client = new AssuanSocketClient();
        try {
            await client.connect(socketPath);

            // SHA-512 of a known test payload (same as Phase 1 test 7)
            const sha512hex = crypto.createHash('sha512')
                .update(Buffer.from('test data'))
                .digest('hex')
                .toUpperCase();

            await assertOk(client, `OPTION agent-awareness=2.1.0`);
            await assertOk(client, 'RESET');
            await assertOk(client, `SIGKEY ${keygrip}`);
            await assertOk(client, 'SETKEYDESC Integration+Test+Signing+via+Proxy');
            await assertOk(client, `SETHASH 10 ${sha512hex}`);

            const signResponse = await client.sendCommand('PKSIGN');
            expect(signResponse).to.match(/^D /m,
                `PKSIGN should return D <signature>, got: ${signResponse.substring(0, 100)}`);
            expect(signResponse).to.match(/OK\s*$/m, 'PKSIGN response should end with OK');
        } finally {
            client.close();
        }
    });

    // -----------------------------------------------------------------------
    // 6. Graceful disconnect (BYE)
    // -----------------------------------------------------------------------
    it('6. BYE command causes clean socket close without error', async function () {
        const client = new AssuanSocketClient();
        let closeErrored = false;

        await client.connect(socketPath);

        // Listen for socket close; if it emitted an error the test will see it.
        // We close before the test assertion, so teardown is always clean.
        await new Promise<void>((resolve) => {
            // Access the internal socket via a type assertion so we can track the close event.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const socket = (client as any).socket as import('net').Socket | null;
            if (!socket) {
                resolve();
                return;
            }
            socket.once('close', (hadError: boolean) => {
                closeErrored = hadError;
                resolve();
            });
            // BYE closes the connection from the agent side; send and don't wait for a response.
            socket.write('BYE\n', 'latin1');
        });

        client.close(); // safe to call even if already closed
        expect(closeErrored, 'socket should close cleanly after BYE (no hadError)').to.be.false;
    });

    // -----------------------------------------------------------------------
    // 7. Multiple concurrent clients — session isolation
    // -----------------------------------------------------------------------
    it('7. three concurrent clients receive independent sessions, responses not cross-contaminated', async function () {
        const clients = [new AssuanSocketClient(), new AssuanSocketClient(), new AssuanSocketClient()];

        try {
            // Connect all three concurrently
            const greetings = await Promise.all(clients.map(c => c.connect(socketPath)));
            greetings.forEach((g, i) => {
                expect(g).to.match(/^OK/, `client ${i} greeting should start with OK`);
            });

            // Send GETINFO version on all three concurrently
            const responses = await Promise.all(clients.map(c => c.sendCommand('GETINFO version')));
            responses.forEach((r, i) => {
                expect(r).to.match(/^D \d+/m, `client ${i} should get D <version>`);
                expect(r).to.match(/OK\s*$/m, `client ${i} response should end with OK`);
            });

            // Verify second sequential command on each still works (proves no state cross-talk)
            const resets = await Promise.all(clients.map(c => c.sendCommand('RESET')));
            resets.forEach((r, i) => {
                expect(r).to.match(/OK\s*$/m, `client ${i} RESET should return OK`);
            });
        } finally {
            clients.forEach(c => c.close());
        }
    });

    // -----------------------------------------------------------------------
    // 8. stop() cleans up — socket file removed after proxy stops
    //
    // This test STOPS the proxy. It must run last. The after() hook calls
    // gpg-bridge-request.stop as a no-op safety net.
    // -----------------------------------------------------------------------
    it('8. stop() removes the socket file', async function () {
        // Confirm socket exists before stop
        expect(fs.existsSync(socketPath), 'socket should exist before stop').to.be.true;

        await vscode.commands.executeCommand('gpg-bridge-request.stop');

        // Socket file should be removed by stop()
        expect(fs.existsSync(socketPath), 'socket file should be removed after stop').to.be.false;
    });
});

// ---------------------------------------------------------------------------
// Phase 5 — RequestProxy uses GpgCli for socket path and stale file removal
// ---------------------------------------------------------------------------

describe('Phase 5 — RequestProxy uses GpgCli for socket path', function () {
    // gpgconf subprocess + proxy restart; 30 s is generous for both.
    this.timeout(30000);

    let listdirs = (name: string) => spawnSync('gpgconf', ['--list-dirs', name], { encoding: 'utf-8', timeout: 5000, shell: false });
    let proxySocketPath: string;

    before(async function () {
        // Phase 2 test 8 stops the proxy; restart it so Phase 5 can run.
        // extension.ts startRequestProxy() is idempotent — safe to call when already running.
        await vscode.commands.executeCommand('gpg-bridge-request.start');
        // Allow async proxy start to fully settle before reading the socket path.
        await new Promise(resolve => setTimeout(resolve, 500));

        const p = await vscode.commands.executeCommand<string | null>(
            '_gpg-bridge-request.test.getSocketPath'
        );
        if (!p) {
            throw new Error('_gpg-bridge-request.test.getSocketPath returned null — proxy did not start');
        }
        proxySocketPath = p;
        await vscode.commands.executeCommand('gpg-bridge-request.stop');
    });

    beforeEach(async function () {
        await vscode.commands.executeCommand('gpg-bridge-request.start');
    });

    afterEach(async function () {
        await vscode.commands.executeCommand('gpg-bridge-request.stop');
    });

    // -----------------------------------------------------------------------
    // 1. Socket path comes from gpgconf
    // -----------------------------------------------------------------------
    it('1. active socket path matches gpgconf --list-dirs agent-socket', function () {
        const result = listdirs('agent-socket');
        expect(result.status, 'gpgconf should exit 0').to.equal(0);
        const expectedPath = result.stdout.trim();
        expect(expectedPath, 'gpgconf must return a non-empty path').to.have.length.greaterThan(0);
        expect(proxySocketPath, 'proxy socket path must match gpgconf agent-socket').to.equal(expectedPath);
    });

    // -----------------------------------------------------------------------
    // 2. Stale socket files at both agent-socket and agent-extra-socket are
    //    removed before the proxy binds on start()
    // -----------------------------------------------------------------------
    it('2. stale files at agent-socket and agent-extra-socket are removed on start()', async function () {
        // Resolve both paths via gpgconf so the test is independent of hard-coded paths.
        const agentResult = listdirs('agent-socket');
        const extraResult = listdirs('agent-extra-socket');
        const agentPath = agentResult.stdout.trim();
        const extraPath = extraResult.stdout.trim();
        expect(agentPath, 'gpgconf must return agent-socket path').to.have.length.greaterThan(0);
        expect(extraPath, 'gpgconf must return agent-extra-socket path').to.have.length.greaterThan(0);

        // Stop the proxy so we can safely plant stale marker files.
        await vscode.commands.executeCommand('gpg-bridge-request.stop');

        // Plant regular files (not sockets) at both paths as stale markers.
        // mkdirSync is a safety net; the parent directory should already exist
        // from the proxy's previous run.
        fs.mkdirSync(path.dirname(agentPath), { recursive: true });
        fs.mkdirSync(path.dirname(extraPath), { recursive: true });
        fs.writeFileSync(agentPath, 'stale-agent-socket-marker');
        fs.writeFileSync(extraPath, 'stale-extra-socket-marker');
        expect(fs.existsSync(agentPath), 'stale agent-socket file must exist before start').to.be.true;
        expect(fs.existsSync(extraPath), 'stale extra-socket file must exist before start').to.be.true;

        // Start the proxy — it must remove both stale files before binding.
        await vscode.commands.executeCommand('gpg-bridge-request.start');
        await new Promise(resolve => setTimeout(resolve, 500));

        // agent-extra-socket: removed and NOT recreated by the proxy (it only binds to agent-socket).
        expect(fs.existsSync(extraPath), 'stale agent-extra-socket file must be removed on start()').to.be.false;

        // agent-socket: stale file removed; proxy created a real socket in its place.
        // Verify by connecting and getting a valid greeting (proves the socket is live).
        const client = new AssuanSocketClient();
        try {
            const greeting = await client.connect(agentPath);
            expect(greeting, 'proxy must accept connections at the gpgconf-resolved agent-socket path').to.match(/^OK/);
        } finally {
            client.close();
        }
    });
});

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Send a command and assert the response ends with OK.
 * Throws a descriptive error if the agent returns ERR or an unexpected response.
 */
async function assertOk(client: AssuanSocketClient, cmd: string): Promise<string> {
    const response = await client.sendCommand(cmd);
    expect(response, `${cmd.trim()} response`).to.match(/OK\s*$/m);
    return response;
}
